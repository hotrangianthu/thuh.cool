# 02 - Database Schema & Patterns

## Overview

DearStory uses PostgreSQL via Supabase with comprehensive Row Level Security (RLS) policies. This document covers the complete database architecture, relationships, and best practices.

---

## Core Database Principles

### 1. **Row Level Security (RLS) First**
- Every table has RLS enabled
- Policies enforce data access at database level
- No need for backend authorization logic

### 2. **UUID Primary Keys**
- All tables use UUID v4 for primary keys
- Auto-generated with `uuid_generate_v4()`
- Better for distributed systems and security

### 3. **Timestamps Everywhere**
- `created_at` on all tables
- `updated_at` on mutable tables
- Automatic timestamps with triggers

### 4. **JSONB for Flexibility**
- Use JSONB for semi-structured data
- Allows schema evolution without migrations
- Still queryable with PostgreSQL JSON operators

---

## Complete Schema

### User Management

#### **user_profiles**
```sql
CREATE TABLE public.user_profiles (
  id uuid PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  email varchar NOT NULL UNIQUE,
  full_name varchar,
  avatar_url text,
  phone varchar,
  date_of_birth timestamp with time zone,
  preferences jsonb DEFAULT '{}'::jsonb,
  is_admin boolean DEFAULT false,
  is_waitlist boolean DEFAULT false,
  waitlist_source varchar,
  created_at timestamp with time zone DEFAULT now(),
  updated_at timestamp with time zone DEFAULT now()
);
```

**Key Points**:
- `id` references Supabase Auth's `auth.users` table
- Cascade delete when user account deleted
- `preferences` JSONB stores user settings flexibly
- `is_admin` flag for role-based access control

**RLS Policy**:
```sql
-- Users can view their own profile
CREATE POLICY "Users can view own profile"
  ON user_profiles FOR SELECT
  USING (auth.uid() = id);

-- Users can update their own profile
CREATE POLICY "Users can update own profile"
  ON user_profiles FOR UPDATE
  USING (auth.uid() = id);

-- Admins can view all profiles
CREATE POLICY "Admins can view all profiles"
  ON user_profiles FOR SELECT
  USING (
    EXISTS (
      SELECT 1 FROM user_profiles
      WHERE id = auth.uid() AND is_admin = true
    )
  );
```

---

### Story Management

#### **stories**
```sql
CREATE TABLE public.stories (
  id uuid PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id uuid REFERENCES user_profiles(id) ON DELETE CASCADE,
  order_id uuid REFERENCES orders(id) ON DELETE SET NULL,
  title varchar NOT NULL,
  story_type varchar NOT NULL CHECK (
    story_type IN ('romance', 'children', 'family', 'milestone', 'memorial', 'other')
  ),
  story_data jsonb NOT NULL DEFAULT '{}'::jsonb,
  status varchar DEFAULT 'draft' CHECK (
    status IN ('draft', 'submitted', 'confirmed', 'in_progress', 
               'in_delivery', 'completed', 'delivered', 'deleted')
  ),
  delivery_date timestamp with time zone,
  pdf_url text,
  digital_url text,
  cover_image_url text,
  pages_metadata jsonb DEFAULT '{}'::jsonb,
  is_public boolean DEFAULT false,
  gallery_template varchar DEFAULT 'motion-carousel' CHECK (
    gallery_template IN ('motion-carousel', 'stack-3d', 'parallax-layers', 
                         'glass-morph', 'floating-cards', 'magazine-spread')
  ),
  gallery_display_order integer DEFAULT 0,
  gallery_hidden boolean DEFAULT false,
  created_at timestamp with time zone DEFAULT now(),
  updated_at timestamp with time zone DEFAULT now()
);
```

**Key Points**:
- `story_data` JSONB stores all story details (characters, scenes, preferences)
- `status` tracks story lifecycle from draft to delivered
- `is_public` controls gallery visibility
- `pages_metadata` stores extracted page count and other info

**Status Lifecycle**:
```
draft → submitted → confirmed → in_progress → in_delivery → completed → delivered
```

**RLS Policies**:
```sql
-- Users can view their own stories
CREATE POLICY "Users can view own stories"
  ON stories FOR SELECT
  USING (auth.uid() = user_id OR is_public = true);

-- Users can create stories
CREATE POLICY "Users can create stories"
  ON stories FOR INSERT
  WITH CHECK (auth.uid() = user_id);

-- Users can update their own draft/submitted stories
CREATE POLICY "Users can update own draft stories"
  ON stories FOR UPDATE
  USING (auth.uid() = user_id AND status IN ('draft', 'submitted'));

-- Admins can do everything
CREATE POLICY "Admins can manage all stories"
  ON stories FOR ALL
  USING (
    EXISTS (
      SELECT 1 FROM user_profiles
      WHERE id = auth.uid() AND is_admin = true
    )
  );
```

#### **story_pages**
```sql
CREATE TABLE public.story_pages (
  id uuid PRIMARY KEY DEFAULT uuid_generate_v4(),
  story_id uuid NOT NULL REFERENCES stories(id) ON DELETE CASCADE,
  page_number integer NOT NULL,
  page_image_url text,
  background_audio_url text,
  narration_audio_url text,
  visual_effects jsonb DEFAULT '{}'::jsonb,
  reading_options jsonb DEFAULT '{}'::jsonb,
  custom_metadata jsonb DEFAULT '{}'::jsonb,
  created_at timestamp with time zone DEFAULT now(),
  updated_at timestamp with time zone DEFAULT now(),
  UNIQUE(story_id, page_number)
);
```

**Key Points**:
- One record per page
- `page_number` ensures ordering
- Audio URLs for background music and narration
- `reading_options` stores auto-play, auto-advance settings

**Reading Options Example**:
```json
{
  "autoPlay": true,
  "autoAdvance": true,
  "advanceDelay": 5000,
  "backgroundPlayAcrossPages": true,
  "narrationPlayAcrossPages": false
}
```

---

### E-Commerce

#### **products**
```sql
CREATE TABLE public.products (
  id uuid PRIMARY KEY DEFAULT uuid_generate_v4(),
  name varchar NOT NULL,
  description text NOT NULL,
  category varchar NOT NULL,
  base_price numeric NOT NULL,
  digital_price numeric,
  physical_price numeric,
  is_active boolean DEFAULT true,
  created_at timestamp with time zone DEFAULT now(),
  updated_at timestamp with time zone DEFAULT now()
);
```

#### **orders**
```sql
CREATE TABLE public.orders (
  id uuid PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id uuid REFERENCES user_profiles(id) ON DELETE SET NULL,
  order_number varchar NOT NULL UNIQUE,
  status varchar DEFAULT 'pending' CHECK (
    status IN ('pending', 'paid', 'processing', 'completed', 'cancelled', 'refunded')
  ),
  total_amount numeric NOT NULL,
  currency varchar DEFAULT 'USD',
  payment_intent_id varchar,
  payment_method varchar,
  payment_confirmed_at timestamp with time zone,
  payment_confirmed_by uuid REFERENCES user_profiles(id),
  shipping_address jsonb,
  billing_address jsonb,
  created_at timestamp with time zone DEFAULT now(),
  updated_at timestamp with time zone DEFAULT now()
);
```

**Key Points**:
- `order_number` is human-readable (e.g., "DS-2024-001")
- `payment_confirmed_by` tracks which admin confirmed payment
- Addresses stored as JSONB for flexibility

**Order Status Lifecycle**:
```
pending → paid → processing → completed
         ↓
    cancelled / refunded
```

#### **order_items**
```sql
CREATE TABLE public.order_items (
  id uuid PRIMARY KEY DEFAULT uuid_generate_v4(),
  order_id uuid REFERENCES orders(id) ON DELETE CASCADE,
  product_id uuid REFERENCES products(id) ON DELETE SET NULL,
  quantity integer DEFAULT 1,
  unit_price numeric NOT NULL,
  total_price numeric NOT NULL,
  created_at timestamp with time zone DEFAULT now()
);
```

---

### Time Capsules (Scheduled Delivery)

#### **time_capsules**
```sql
CREATE TABLE public.time_capsules (
  id uuid PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id uuid REFERENCES user_profiles(id) ON DELETE CASCADE,
  story_id uuid REFERENCES stories(id) ON DELETE CASCADE,
  recipient_email varchar NOT NULL,
  recipient_id uuid REFERENCES user_profiles(id) ON DELETE SET NULL,
  delivery_date timestamp with time zone NOT NULL,
  message text,
  is_delivered boolean DEFAULT false,
  delivery_token varchar UNIQUE NOT NULL,
  viewed_at timestamp with time zone,
  created_at timestamp with time zone DEFAULT now()
);

-- Index for efficient cron job queries
CREATE INDEX idx_time_capsules_delivery 
  ON time_capsules(delivery_date, is_delivered) 
  WHERE is_delivered = false;
```

**Key Points**:
- `delivery_token` is UUID for secure access
- `recipient_id` links to user if they have account
- Index optimizes cron job that delivers capsules

**Worker Query (runs every hour)**:
```sql
SELECT * FROM time_capsules
WHERE is_delivered = false
  AND delivery_date <= NOW()
ORDER BY delivery_date ASC;
```

---

### Sharing & Collaboration

#### **family_rooms**
```sql
CREATE TABLE public.family_rooms (
  id uuid PRIMARY KEY DEFAULT uuid_generate_v4(),
  owner_id uuid REFERENCES user_profiles(id) ON DELETE CASCADE,
  name varchar NOT NULL,
  description text,
  access_code varchar UNIQUE NOT NULL,
  is_private boolean DEFAULT true,
  created_at timestamp with time zone DEFAULT now(),
  updated_at timestamp with time zone DEFAULT now()
);
```

#### **family_room_members**
```sql
CREATE TABLE public.family_room_members (
  id uuid PRIMARY KEY DEFAULT uuid_generate_v4(),
  room_id uuid REFERENCES family_rooms(id) ON DELETE CASCADE,
  user_id uuid REFERENCES user_profiles(id) ON DELETE CASCADE,
  role varchar DEFAULT 'member' CHECK (
    role IN ('owner', 'admin', 'member', 'viewer')
  ),
  joined_at timestamp with time zone DEFAULT now(),
  UNIQUE(room_id, user_id)
);
```

#### **story_shares**
```sql
CREATE TABLE public.story_shares (
  id uuid PRIMARY KEY DEFAULT uuid_generate_v4(),
  story_id uuid REFERENCES stories(id) ON DELETE CASCADE,
  shared_by uuid REFERENCES user_profiles(id) ON DELETE CASCADE,
  share_type varchar DEFAULT 'private_link' CHECK (
    share_type IN ('public', 'family_room', 'private_link')
  ),
  family_room_id uuid REFERENCES family_rooms(id) ON DELETE CASCADE,
  access_token varchar UNIQUE,
  expires_at timestamp with time zone,
  view_count integer DEFAULT 0,
  created_at timestamp with time zone DEFAULT now()
);
```

---

### Marketing & Growth

#### **referrals**
```sql
CREATE TABLE public.referrals (
  id uuid PRIMARY KEY DEFAULT uuid_generate_v4(),
  referrer_id uuid REFERENCES user_profiles(id) ON DELETE CASCADE,
  referred_email varchar NOT NULL,
  referred_user_id uuid REFERENCES user_profiles(id) ON DELETE SET NULL,
  status varchar DEFAULT 'pending' CHECK (
    status IN ('pending', 'completed', 'expired')
  ),
  reward_amount numeric DEFAULT 0,
  created_at timestamp with time zone DEFAULT now(),
  completed_at timestamp with time zone
);
```

#### **testimonials**
```sql
CREATE TABLE public.testimonials (
  id uuid PRIMARY KEY DEFAULT uuid_generate_v4(),
  name varchar NOT NULL,
  role varchar NOT NULL,
  text text NOT NULL,
  image_url text NOT NULL,
  rating integer DEFAULT 5 CHECK (rating BETWEEN 1 AND 5),
  is_featured boolean DEFAULT false,
  created_at timestamp with time zone DEFAULT now(),
  updated_at timestamp with time zone DEFAULT now()
);
```

#### **portfolio_items**
```sql
CREATE TABLE public.portfolio_items (
  id uuid PRIMARY KEY DEFAULT uuid_generate_v4(),
  title varchar NOT NULL,
  category varchar NOT NULL,
  description text NOT NULL,
  image_url text NOT NULL,
  tags text[] DEFAULT ARRAY[]::text[],
  is_featured boolean DEFAULT false,
  created_at timestamp with time zone DEFAULT now(),
  updated_at timestamp with time zone DEFAULT now()
);
```

---

### Contact & Support

#### **contact_messages**
```sql
CREATE TABLE public.contact_messages (
  id uuid PRIMARY KEY DEFAULT uuid_generate_v4(),
  name varchar NOT NULL,
  email varchar NOT NULL,
  subject varchar NOT NULL,
  message text NOT NULL,
  is_read boolean DEFAULT false,
  created_at timestamp with time zone DEFAULT now()
);
```

---

## Database Patterns & Best Practices

### 1. **Soft Deletes**
```sql
-- Add deleted status to stories
ALTER TABLE stories
  ADD COLUMN deleted_at timestamp with time zone;

-- Update RLS to exclude deleted
CREATE POLICY "Exclude deleted stories"
  ON stories FOR SELECT
  USING (deleted_at IS NULL AND (auth.uid() = user_id OR is_public = true));
```

### 2. **Automatic Timestamps**
```sql
-- Create function
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Create trigger
CREATE TRIGGER update_stories_updated_at
  BEFORE UPDATE ON stories
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();
```

### 3. **Computed Columns (Virtual)**
```sql
-- Example: Full name from first + last
ALTER TABLE user_profiles
  ADD COLUMN display_name varchar GENERATED ALWAYS AS (
    COALESCE(full_name, email)
  ) STORED;
```

### 4. **Full-Text Search**
```sql
-- Add tsvector column
ALTER TABLE stories
  ADD COLUMN search_vector tsvector;

-- Create index
CREATE INDEX stories_search_idx
  ON stories USING gin(search_vector);

-- Update function
CREATE OR REPLACE FUNCTION stories_search_trigger()
RETURNS TRIGGER AS $$
BEGIN
  NEW.search_vector := to_tsvector('english',
    COALESCE(NEW.title, '') || ' ' ||
    COALESCE(NEW.story_data->>'description', '')
  );
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger
CREATE TRIGGER stories_search_update
  BEFORE INSERT OR UPDATE ON stories
  FOR EACH ROW
  EXECUTE FUNCTION stories_search_trigger();

-- Query example
SELECT * FROM stories
WHERE search_vector @@ to_tsquery('english', 'love & story');
```

---

## Common Query Patterns

### 1. **Get User's Stories with Pagination**
```sql
SELECT
  s.*,
  COUNT(*) OVER() AS total_count
FROM stories s
WHERE s.user_id = :userId
  AND s.deleted_at IS NULL
ORDER BY s.created_at DESC
LIMIT :limit OFFSET :offset;
```

### 2. **Get Order with Items**
```sql
SELECT
  o.*,
  json_agg(
    json_build_object(
      'id', oi.id,
      'product_id', oi.product_id,
      'quantity', oi.quantity,
      'unit_price', oi.unit_price,
      'total_price', oi.total_price,
      'product', json_build_object(
        'name', p.name,
        'description', p.description
      )
    )
  ) AS items
FROM orders o
LEFT JOIN order_items oi ON oi.order_id = o.id
LEFT JOIN products p ON p.id = oi.product_id
WHERE o.id = :orderId
GROUP BY o.id;
```

### 3. **Get Public Stories with User Info**
```sql
SELECT
  s.*,
  json_build_object(
    'full_name', u.full_name,
    'avatar_url', u.avatar_url
  ) AS user
FROM stories s
INNER JOIN user_profiles u ON u.id = s.user_id
WHERE s.is_public = true
  AND s.gallery_hidden = false
  AND s.deleted_at IS NULL
ORDER BY s.gallery_display_order ASC, s.created_at DESC;
```

---

## Performance Optimization

### Essential Indexes
```sql
-- Stories
CREATE INDEX idx_stories_user_id ON stories(user_id);
CREATE INDEX idx_stories_order_id ON stories(order_id);
CREATE INDEX idx_stories_status ON stories(status);
CREATE INDEX idx_stories_public ON stories(is_public) WHERE is_public = true;

-- Story Pages
CREATE INDEX idx_story_pages_story_id ON story_pages(story_id);

-- Orders
CREATE INDEX idx_orders_user_id ON orders(user_id);
CREATE INDEX idx_orders_status ON orders(status);
CREATE INDEX idx_orders_created_at ON orders(created_at DESC);

-- Time Capsules
CREATE INDEX idx_time_capsules_delivery 
  ON time_capsules(delivery_date, is_delivered) 
  WHERE is_delivered = false;

-- Referrals
CREATE INDEX idx_referrals_referrer ON referrals(referrer_id);
CREATE INDEX idx_referrals_status ON referrals(status);
```

### Composite Indexes
```sql
-- For filtering + sorting
CREATE INDEX idx_stories_user_status_created
  ON stories(user_id, status, created_at DESC);

-- For join optimization
CREATE INDEX idx_order_items_order_product
  ON order_items(order_id, product_id);
```

---

## Migration Strategy

### 1. **Create Migration File**
```sql
-- database/migrations/YYYYMMDD_description.sql

-- Migration: Add gallery features
-- Date: 2024-01-15

BEGIN;

-- Add new columns
ALTER TABLE stories
  ADD COLUMN gallery_template varchar DEFAULT 'motion-carousel',
  ADD COLUMN gallery_display_order integer DEFAULT 0,
  ADD COLUMN gallery_hidden boolean DEFAULT false;

-- Add constraints
ALTER TABLE stories
  ADD CONSTRAINT check_gallery_template
  CHECK (gallery_template IN ('motion-carousel', 'stack-3d', ...));

-- Create indexes
CREATE INDEX idx_stories_gallery ON stories(gallery_display_order)
  WHERE is_public = true AND gallery_hidden = false;

COMMIT;
```

### 2. **Run Migration**
```bash
# In Supabase SQL Editor, paste and run the migration
# Or use CLI:
supabase db push
```

### 3. **Rollback Plan**
```sql
-- Always include rollback
BEGIN;

ALTER TABLE stories
  DROP COLUMN gallery_template,
  DROP COLUMN gallery_display_order,
  DROP COLUMN gallery_hidden;

DROP INDEX IF EXISTS idx_stories_gallery;

COMMIT;
```

---

## Security Best Practices

### 1. **Always Enable RLS**
```sql
ALTER TABLE stories ENABLE ROW LEVEL SECURITY;
```

### 2. **Test RLS Policies**
```sql
-- Test as specific user
SET LOCAL role = 'anon';
SET LOCAL request.jwt.claim.sub = 'user-uuid-here';

-- Try query
SELECT * FROM stories;

-- Reset
RESET role;
```

### 3. **Use Service Role Sparingly**
```javascript
// Only for admin operations
const { data } = await supabaseAdmin
  .from('stories')
  .update({ status: 'confirmed' })
  .eq('id', storyId);
```

### 4. **Validate Input**
```sql
-- Use CHECK constraints
ALTER TABLE stories
  ADD CONSTRAINT check_status
  CHECK (status IN ('draft', 'submitted', ...));

-- Use JSONB schema validation (PostgreSQL 14+)
ALTER TABLE stories
  ADD CONSTRAINT check_story_data
  CHECK (jsonb_typeof(story_data) = 'object');
```

---

## Common Pitfalls & Solutions

### 1. **RLS Blocking Legitimate Queries**
**Problem**: Query returns no rows even though data exists  
**Solution**: Check RLS policies, use service role for admin operations

### 2. **N+1 Query Problem**
**Problem**: Fetching related data in loops  
**Solution**: Use JOINs or json_agg to fetch in single query

### 3. **Missing Indexes**
**Problem**: Slow queries on large tables  
**Solution**: Add indexes on foreign keys and frequently filtered columns

### 4. **JSONB Queries Slow**
**Problem**: Filtering on JSONB fields is slow  
**Solution**: Create GIN index on JSONB column

```sql
CREATE INDEX idx_story_data_gin ON stories USING gin(story_data);

-- Query example
SELECT * FROM stories
WHERE story_data @> '{"type": "romance"}';
```

### 5. **Cascade Deletes**
**Problem**: Accidentally deleting related data  
**Solution**: Use SET NULL instead of CASCADE where appropriate

---

## Key Takeaways

1. **RLS is Your Friend**: Database-level security, no backend needed
2. **UUIDs Everywhere**: Better for distributed systems and security
3. **JSONB for Flexibility**: Schema evolution without migrations
4. **Index Everything Important**: Foreign keys, status fields, timestamps
5. **Test Your Policies**: Always test RLS policies with real user context
6. **Migrations Are Version Control**: Never edit schema directly, always use migrations

---

**This schema has been battle-tested with real users. Copy it, adapt it, and build on it for your next project.**

